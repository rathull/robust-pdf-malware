import os
import argparse
import pickle
import numpy as np
import pandas as pd
from tqdm import tqdm
import matplotlib.pyplot as plt

def generate_markov_chain(string_of_bytes):
    bytes = np.frombuffer(string_of_bytes.encode('utf-8'), dtype=np.uint8)
    transition_matrix = np.zeros((256, 256), dtype=np.float64)

    # Genererate transitions for Markov chain
    for i in range(len(bytes) - 1):
        transition_matrix[bytes[i], bytes[i+1]] += 1

    # Normalize probabilities (better contrast)
    # TODO: vectorize properly
    for i in range(256): # all bytes
        occurences_first = np.sum(transition_matrix[i, :])
        if occurences_first > 0:
            transition_matrix[i, :] = transition_matrix[i, :] / occurences_first

    return transition_matrix

# Function to simulate processing the entire dataset
def generate_markov(small):
    # Make sure data exists
    if not os.path.exists('training.csv'):
        raise FileNotFoundError("The file training.csv does not exist.")

    # Load data
    print('Reading csv...')
    df = pd.read_csv('training.csv')
    print('Finished reading csv')
    if small:
        df = df.head(10)
    df = df.drop(columns=['name', 'id'])
    strings_of_bytes = df['contents'].to_numpy()
    
    # Populate with byteplots
    X = [generate_markov_chain(i) 
         for i in tqdm(strings_of_bytes, desc="Generating markov plots")]
    # Populate with labels
    y = df['label'].to_numpy()
    
    # plt.figure(figsize=(10, 8))
    # plt.imshow(X[3], cmap='viridis', interpolation='nearest', norm=plt.Normalize(vmin=0, vmax=np.max(X[3])//20))
    # plt.colorbar()
    # plt.title('abc')
    # plt.xlabel('From')
    # plt.ylabel('To')
    # plt.show()

    with open('markovs.pkl', 'wb') as f:
        pickle.dump(X, f, pickle.HIGHEST_PROTOCOL)

    with open('labels.pkl', 'wb') as f:
        pickle.dump(y, f, pickle.HIGHEST_PROTOCOL)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Process some data.')
    parser.add_argument('--small', action='store_true',
                        help='Process a small portion of the dataset')
    
    args = parser.parse_args()
    
    generate_markov(args.small)
