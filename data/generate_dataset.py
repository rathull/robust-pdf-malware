import os
import argparse
import pickle
import numpy as np
import pandas as pd
from tqdm import tqdm

def generate_markov_chain(string_of_bytes: str) -> np.ndarray:
    '''
    Generate a Markov chain transition matrix from a string of bytes.

    Args:
    string_of_bytes (str): The string to be converted into a Markov chain.

    Returns:
    np.ndarray: The generated Markov chain transition matrix.
    '''
    bytes = np.frombuffer(string_of_bytes.encode('utf-8'), dtype=np.uint8)
    transition_matrix = np.zeros((256, 256), dtype=np.float64)

    for i in range(len(bytes) - 1):
        transition_matrix[bytes[i], bytes[i + 1]] += 1

    for i in range(256):
        occurrences_first = np.sum(transition_matrix[i, :])
        if occurrences_first > 0:
            transition_matrix[i, :] = transition_matrix[i, :] / occurrences_first

    return transition_matrix

def generate_markovs(strings_of_bytes: np.ndarray) -> None:
    '''
    Generate Markov chains for each entry in a dataset and save the results.

    Args:
    strings_of_bytes (np.ndarray): Array of strings to be converted into Markov chains.
    '''
    X = [generate_markov_chain(i) for i in tqdm(strings_of_bytes, desc="Generating markov plots")]

    with open('markovs.pkl', 'wb') as f:
        pickle.dump(X, f, pickle.HIGHEST_PROTOCOL)

def byteplot_from_bytes(string_of_bytes: str, width: int = 256) -> np.ndarray:
    '''
    Generate a byte plot from a string of bytes.

    Args:
    string_of_bytes (str): The string to be converted into a byte plot.
    width (int): The width of the byte plot.

    Returns:
    np.ndarray: The generated byte plot.
    '''
    bytes = np.frombuffer(string_of_bytes.encode('utf-8'), dtype=np.uint8)
    height = int(np.ceil(len(bytes) / width))
    byte_length = width * height
    plot = np.zeros(byte_length, dtype=np.uint8)
    plot[:len(bytes)] = bytes
    plot = plot.reshape((height, width))
    return plot

def generate_byteplots(strings_of_bytes: np.ndarray) -> None:
    '''
    Generate byte plots for each entry in a dataset and save the results.

    Args:
    strings_of_bytes (np.ndarray): Array of strings to be converted into byte plots.
    '''
    X = [byteplot_from_bytes(i) for i in tqdm(strings_of_bytes, desc="Generating byte plots")]

    with open('byteplots.pkl', 'wb') as f:
        pickle.dump(X, f, pickle.HIGHEST_PROTOCOL)

def process_dataset(small: bool) -> None:
    '''
    Process the dataset to generate and save Markov chains and byte plots.

    Args:
    small (bool): Whether to process a small portion of the dataset or not.
    '''
    if not os.path.exists('training.csv'):
        raise FileNotFoundError("The file training.csv does not exist.")

    print('Reading csv...')
    df = pd.read_csv('training.csv')
    print('Finished reading csv')

    if small:
        df = df.head(10)

    df = df.drop(columns=['name', 'id'])
    strings_of_bytes = df['contents'].to_numpy()

    generate_markovs(strings_of_bytes)
    generate_byteplots(strings_of_bytes)
    
    y = df['label'].to_numpy()
    with open('labels.pkl', 'wb') as f:
        pickle.dump(y, f, pickle.HIGHEST_PROTOCOL)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Process some data.')
    parser.add_argument('--small', action='store_true', help='Process a small portion of the dataset')
    args = parser.parse_args()

    process_dataset(args.small)
