import os
import argparse
import pickle
import numpy as np
import pandas as pd
from tqdm import tqdm
import ast

def recover_pdf_bytes_from_csv_row(data_str: str) -> bytes:
    """
    Convert a string representation of byte data back to actual bytes.

    Args:
    data_str (str): String representation of byte data.

    Returns:
    bytes: The original byte data.
    """
    # Evaluate the byte string to convert it back to bytes
    bytecode_str = ast.literal_eval(data_str)

    # Decode the bytecode to get the string, then clean it
    bytecode_str = bytecode_str.decode('utf-8')
    data_str_cleaned = ''.join(bytecode_str[i] for i in range(len(bytecode_str)) if (i + 1) % 5 != 0)

    # Handle the "b''" at the beginning and end of the string
    if data_str_cleaned.startswith("b'") and data_str_cleaned.endswith("'"):
        data_str_cleaned = data_str_cleaned[2:-1]

    # Convert the cleaned string back to bytes
    try:
        x_recovered = ast.literal_eval(f"b'{data_str_cleaned}'")
    except Exception as e:
        print(f'Could not recover: {e}')
        x_recovered = None
    return x_recovered

def generate_markov_chain(string_of_bytes: bytes) -> np.ndarray:
    """
    Generate a Markov chain transition matrix from a string of bytes.

    Args:
    string_of_bytes (bytes): The byte data to be converted into a Markov chain.

    Returns:
    np.ndarray: The generated Markov chain transition matrix.
    """
    transition_matrix = np.zeros((256, 256), dtype=np.float64)
    
    # Ensure string_of_bytes is an iterable of integers for matrix indexing
    byte_list = list(string_of_bytes)

    for i in range(len(byte_list) - 1):
        transition_matrix[byte_list[i], byte_list[i + 1]] += 1

    for i in range(256):
        row_sum = np.sum(transition_matrix[i, :])
        if row_sum > 0:
            transition_matrix[i, :] /= row_sum

    return transition_matrix

def generate_markovs(strings_of_bytes: np.ndarray) -> None:
    """
    Generate Markov chains for each entry in a dataset and save the results.

    Args:
    strings_of_bytes (np.ndarray): Array of byte data to be converted into Markov chains.
    """
    X = [generate_markov_chain(i) for i in tqdm(strings_of_bytes, desc="Generating markov plots")]
    with open('markovs.pkl', 'wb') as f:
        pickle.dump(X, f, pickle.HIGHEST_PROTOCOL)

def byteplot_from_bytes(string_of_bytes: bytes, width: int = 256) -> np.ndarray:
    """
    Generate a byte plot from a string of bytes.

    Args:
    string_of_bytes (bytes): The byte data to be converted into a byte plot.
    width (int): The width of the byte plot.

    Returns:
    np.ndarray: The generated byte plot.
    """
    byte_array = np.frombuffer(string_of_bytes, dtype=np.uint8)
    height = int(np.ceil(len(byte_array) / width))
    byte_length = width * height
    
    plot = np.zeros(byte_length, dtype=np.uint8)
    plot[:len(byte_array)] = byte_array
    
    return plot.reshape((height, width))

def generate_byteplots(strings_of_bytes: np.ndarray) -> None:
    """
    Generate byte plots for each entry in a dataset and save the results.

    Args:
    strings_of_bytes (np.ndarray): Array of byte data to be converted into byte plots.
    """
    X = [byteplot_from_bytes(i) for i in tqdm(strings_of_bytes, desc="Generating byte plots")]
    with open('byteplots.pkl', 'wb') as f:
        pickle.dump(X, f, pickle.HIGHEST_PROTOCOL)

def process_dataset(small: bool) -> None:
    """
    Process the dataset to generate and save Markov chains and byte plots.

    Args:
    small (bool): Whether to process a small portion of the dataset or not.
    """
    if not os.path.exists('training.csv'):
        raise FileNotFoundError("The file training.csv does not exist.")

    print('Reading csv...')
    df = pd.read_csv('training.csv')
    print('Finished reading csv.')

    if small:
        df = df.head(10)

    df = df.drop(columns=['name', 'id'])
    print('Processing PDF bytes...')

    strings_of_bytes = df['contents'].to_numpy()
    y = df['label'].to_numpy()

    for i in tqdm(range(len(strings_of_bytes)), desc='Processing PDF bytes'):
        strings_of_bytes[i] = recover_pdf_bytes_from_csv_row(strings_of_bytes[i])

    # Create a mask that is True where strings_of_bytes is not None
    mask = strings_of_bytes != None

    # Apply the mask to filter out None values and corresponding labels
    strings_of_bytes = strings_of_bytes[mask]
    y = y[mask]

    print('Done processing PDF bytes')

    # print(strings_of_bytes.shape)
    # print(type(strings_of_bytes), type(strings_of_bytes[0]))

    print('Generating markov plots...')
    generate_markovs(strings_of_bytes)
    print('Done markov plots.')
    print('Generating byteplots...')
    generate_byteplots(strings_of_bytes)
    print('Done byteplots.')
    
    with open('example.pdf', 'wb') as f:
        f.write(strings_of_bytes[3])
    
    with open('labels.pkl', 'wb') as f:
        pickle.dump(y, f, pickle.HIGHEST_PROTOCOL)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Process some data.')
    parser.add_argument('--small', action='store_true', help='Process a small portion of the dataset')
    args = parser.parse_args()

    process_dataset(args.small)
